<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Marble Run Spectacular</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .marble-score {
            margin: 5px 0;
            font-weight: bold;
        }

        #winner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.9);
            display: none;
            animation: winnerPulse 1s ease-in-out infinite;
            z-index: 200;
        }

        @keyframes winnerPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            border: none;
            color: white;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <div style="font-size: 20px; margin-bottom: 10px;">üèÅ Marble Championship</div>
        <div id="raceNum">Race: 1</div>
        <div id="scores"></div>
    </div>
    
    <div id="winner"></div>
    
    <div id="controls">
        <button onclick="toggleCamera()">Change View</button>
        <button onclick="changeTrack()">New Track</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game variables
        let cameraAngle = 0;
        let cameraMode = 0;
        let trackStyle = 0;
        let raceNumber = 1;
        let particles = [];
        let stars = [];
        
        // Create starfield background
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.1
            });
        }

        // Marble class
        class Marble {
            constructor(color, name, lane) {
                this.color = color;
                this.name = name;
                this.lane = lane;
                this.reset();
                this.score = 0;
                this.glow = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                this.trail = [];
            }
            
            reset() {
                this.progress = 0;
                this.x = 0;
                this.y = 0;
                this.z = this.lane * 40;
                this.vx = 0;
                this.vy = 0;
                this.vz = 0;
                this.speed = Math.random() * 0.5 + 0.5;
                this.wobble = Math.random() * Math.PI * 2;
                this.finished = false;
                this.airtime = 0;
                this.rotation = 0;
                this.trail = [];
            }
            
            update() {
                if (this.finished) return;
                
                // Move along track
                this.progress += this.speed * 0.008;
                this.wobble += 0.1;
                this.rotation += this.speed * 0.2;
                
                // Get track position
                const trackData = getTrackPosition(this.progress, this.lane);
                
                // Smooth movement with physics
                const targetX = trackData.x;
                const targetY = trackData.y;
                
                this.vx += (targetX - this.x) * 0.1;
                this.vy += (targetY - this.y) * 0.1;
                this.vx *= 0.9;
                this.vy *= 0.9;
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Add wobble for realism
                this.x += Math.sin(this.wobble) * 2;
                this.y += Math.cos(this.wobble * 0.7) * 1;
                
                // Speed variations based on track
                if (trackData.type === 'loop') {
                    this.speed *= 0.98;
                } else if (trackData.type === 'drop') {
                    this.speed *= 1.02;
                } else if (trackData.type === 'jump') {
                    this.airtime = 20;
                    createParticles(this.x, this.y, this.color);
                }
                
                // Air time physics
                if (this.airtime > 0) {
                    this.airtime--;
                    this.y -= this.airtime * 0.5;
                }
                
                // Random speed bursts
                if (Math.random() < 0.01) {
                    this.speed += Math.random() * 0.3;
                    createParticles(this.x, this.y, this.color);
                }
                
                // Trail effect
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 20) {
                    this.trail.shift();
                }
                
                // Check finish
                if (this.progress >= 1) {
                    this.finished = true;
                    this.onFinish();
                }
                
                this.speed = Math.min(Math.max(this.speed, 0.3), 1.5);
            }
            
            onFinish() {
                // Create celebration particles
                for (let i = 0; i < 30; i++) {
                    createParticles(this.x, this.y, this.color);
                }
            }
            
            draw3D() {
                const perspective = 800;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // 3D transformation
                let x3d = this.x;
                let y3d = this.y;
                let z3d = this.z + 200;
                
                // Rotate camera
                const cos = Math.cos(cameraAngle);
                const sin = Math.sin(cameraAngle);
                const xRot = x3d * cos - z3d * sin;
                const zRot = x3d * sin + z3d * cos;
                
                // Project to 2D
                const scale = perspective / (perspective + zRot);
                const x2d = centerX + xRot * scale;
                const y2d = centerY + y3d * scale;
                const size = 20 * scale;
                
                // Draw trail
                ctx.strokeStyle = this.glow;
                ctx.lineWidth = 3 * scale;
                ctx.beginPath();
                this.trail.forEach((point, i) => {
                    const tScale = perspective / (perspective + zRot);
                    const tx = centerX + point.x * tScale;
                    const ty = centerY + point.y * tScale;
                    if (i === 0) ctx.moveTo(tx, ty);
                    else ctx.lineTo(tx, ty);
                });
                ctx.stroke();
                
                // Draw shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(x2d, y2d + size + 5, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw glow
                const gradient = ctx.createRadialGradient(x2d, y2d, 0, x2d, y2d, size * 2);
                gradient.addColorStop(0, this.glow);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x2d, y2d, size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw marble
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(x2d, y2d, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw highlight
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.beginPath();
                ctx.arc(x2d - size/3, y2d - size/3, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw spinning effect
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x2d, y2d, size * 0.8, this.rotation, this.rotation + Math.PI);
                ctx.stroke();
            }
        }
        
        // Track generation
        function getTrackPosition(progress, lane) {
            const t = progress * Math.PI * 8; // Multiple segments
            let x, y, type = 'normal';
            
            if (trackStyle === 0) {
                // Roller coaster style
                x = Math.sin(t) * 200 + Math.sin(t * 2) * 100;
                y = Math.cos(t) * 150 + Math.sin(t * 3) * 50;
                
                if (progress > 0.3 && progress < 0.4) {
                    // Loop
                    const loopT = (progress - 0.3) * 10 * Math.PI * 2;
                    y -= Math.cos(loopT) * 100;
                    x += Math.sin(loopT) * 50;
                    type = 'loop';
                }
                
                if (progress > 0.6 && progress < 0.65) {
                    type = 'jump';
                }
            } else if (trackStyle === 1) {
                // Figure-8 with hills
                x = Math.sin(t) * 250;
                y = Math.sin(t * 2) * 120 + Math.sin(t * 4) * 40;
                
                if (progress > 0.5 && progress < 0.55) {
                    y -= 100;
                    type = 'drop';
                }
            } else {
                // Spiral with jumps
                const radius = 100 + progress * 200;
                x = Math.cos(t) * radius;
                y = Math.sin(t) * radius * 0.5 + Math.sin(t * 5) * 30;
                
                if (progress % 0.2 < 0.05) {
                    type = 'jump';
                }
            }
            
            // Lane offset
            x += lane * 30 - 75;
            
            return { x, y, type };
        }
        
        // Draw track
        function drawTrack() {
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 2;
            
            for (let lane = 0; lane < 6; lane++) {
                ctx.beginPath();
                for (let i = 0; i <= 100; i++) {
                    const pos = getTrackPosition(i / 100, lane);
                    const perspective = 800;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const z3d = lane * 40 + 200;
                    const cos = Math.cos(cameraAngle);
                    const sin = Math.sin(cameraAngle);
                    const xRot = pos.x * cos - z3d * sin;
                    const zRot = pos.x * sin + z3d * cos;
                    
                    const scale = perspective / (perspective + zRot);
                    const x2d = centerX + xRot * scale;
                    const y2d = centerY + pos.y * scale;
                    
                    if (i === 0) ctx.moveTo(x2d, y2d);
                    else ctx.lineTo(x2d, y2d);
                }
                ctx.stroke();
            }
        }
        
        // Particle system
        function createParticles(x, y, color) {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: color,
                    life: 1
                });
            }
        }
        
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.5;
                p.life -= 0.02;
                return p.life > 0;
            });
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color.replace('rgb', 'rgba').replace(')', `, ${p.life})`);
                ctx.beginPath();
                ctx.arc(canvas.width/2 + p.x, canvas.height/2 + p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Create marbles
        const marbleColors = [
            { color: 'rgb(100,149,237)', name: 'Blue' },
            { color: 'rgb(255,99,71)', name: 'Red' },
            { color: 'rgb(255,215,0)', name: 'Gold' },
            { color: 'rgb(50,205,50)', name: 'Green' },
            { color: 'rgb(238,130,238)', name: 'Purple' },
            { color: 'rgb(255,165,0)', name: 'Orange' }
        ];
        
        const marbles = marbleColors.map((mc, i) => 
            new Marble(mc.color, mc.name, i)
        );
        
        // Auto-start races
        let raceInProgress = true;
        let raceStartDelay = 0;
        
        function checkRaceEnd() {
            if (marbles.every(m => m.finished)) {
                if (raceInProgress) {
                    raceInProgress = false;
                    
                    // Calculate positions
                    const sorted = [...marbles].sort((a, b) => b.progress - a.progress);
                    const points = [10, 6, 4, 3, 2, 1];
                    
                    sorted.forEach((m, i) => {
                        m.score += points[i] || 0;
                    });
                    
                    // Show winner
                    const winner = sorted[0];
                    const winnerDiv = document.getElementById('winner');
                    winnerDiv.textContent = `${winner.name} Wins Race ${raceNumber}!`;
                    winnerDiv.style.color = winner.color;
                    winnerDiv.style.display = 'block';
                    
                    raceNumber++;
                    updateScores();
                    
                    // Auto restart after 3 seconds
                    setTimeout(() => {
                        winnerDiv.style.display = 'none';
                        startNewRace();
                    }, 3000);
                }
            }
        }
        
        function startNewRace() {
            marbles.forEach(m => m.reset());
            raceInProgress = true;
            document.getElementById('raceNum').textContent = `Race: ${raceNumber}`;
        }
        
        function updateScores() {
            const scoresDiv = document.getElementById('scores');
            const sorted = [...marbles].sort((a, b) => b.score - a.score);
            scoresDiv.innerHTML = sorted.map(m => 
                `<div class="marble-score" style="color: ${m.color}">
                    ${m.name}: ${m.score} pts
                </div>`
            ).join('');
        }
        
        // Controls
        function toggleCamera() {
            cameraMode = (cameraMode + 1) % 3;
        }
        
        function changeTrack() {
            trackStyle = (trackStyle + 1) % 3;
            startNewRace();
        }
        
        // Mouse/touch camera control
        let isDragging = false;
        let lastX = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                cameraAngle += (e.clientX - lastX) * 0.01;
                lastX = e.clientX;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('touchstart', (e) => {
            isDragging = true;
            lastX = e.touches[0].clientX;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (isDragging) {
                cameraAngle += (e.touches[0].clientX - lastX) * 0.01;
                lastX = e.touches[0].clientX;
            }
        });
        
        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });
        
        // Animation loop
        function animate() {
            // Clear canvas
            ctx.fillStyle = 'rgba(15,25,45,0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) star.y = 0;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Auto-rotate camera
            if (cameraMode === 1) {
                cameraAngle += 0.005;
            } else if (cameraMode === 2) {
                cameraAngle = Math.sin(Date.now() * 0.0005) * 0.5;
            }
            
            // Draw track
            drawTrack();
            
            // Update and draw marbles
            if (raceInProgress) {
                marbles.forEach(m => m.update());
            }
            
            // Sort marbles by Z position for proper rendering
            const sortedMarbles = [...marbles].sort((a, b) => {
                const aZ = a.z + Math.sin(cameraAngle) * a.x;
                const bZ = b.z + Math.sin(cameraAngle) * b.x;
                return bZ - aZ;
            });
            
            sortedMarbles.forEach(m => m.draw3D());
            
            // Update particles
            updateParticles();
            drawParticles();
            
            // Check for race end
            checkRaceEnd();
            
            requestAnimationFrame(animate);
        }
        
        // Initialize
        updateScores();
        animate();
    </script>
</body>
</html>
